<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/fontawesome/css/brands.css" rel="stylesheet">
<link href="/fontawesome/css/solid.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B0FHXMTYN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B0FHXMTYN');
</script>
<!-- End Google Analytics -->

  
  <title>Windows逆向进阶 | Kizureina&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Hook基础Hook的概念无需多言，简单来讲就是监听某个API函数，来对这个函数做相关操作，之后再跳转回到原本的函数继续执行。 两种Hook方式Hook的方式有inline和address两种。 inline Hook即内联Hook，直接在要Hook的函数处修改机器码，让程序执行跳转到我们写好的地址，来执行我们的函数，执行完后再跳转回到原函数处执行。 address Hook即通过修改call的">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows逆向进阶">
<meta property="og:url" content="https://kizureina.github.io/2024/01/11/galgame-reverse-learning-note/index.html">
<meta property="og:site_name" content="Kizureina&#39;s Blog">
<meta property="og:description" content="Hook基础Hook的概念无需多言，简单来讲就是监听某个API函数，来对这个函数做相关操作，之后再跳转回到原本的函数继续执行。 两种Hook方式Hook的方式有inline和address两种。 inline Hook即内联Hook，直接在要Hook的函数处修改机器码，让程序执行跳转到我们写好的地址，来执行我们的函数，执行完后再跳转回到原函数处执行。 address Hook即通过修改call的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240116003143388.png">
<meta property="og:image" content="https://kizureina.github.io/images/Snipaste_2024-01-14_16-49-38.png">
<meta property="og:image" content="https://kizureina.github.io/images/Snipaste_2024-01-14_17-51-56.png">
<meta property="og:image" content="https://kizureina.github.io/images/Snipaste_2024-01-14_17-53-29.png">
<meta property="og:image" content="https://kizureina.github.io/images/Snipaste_2024-01-15_17-28-35.png">
<meta property="article:published_time" content="2024-01-11T06:55:04.000Z">
<meta property="article:modified_time" content="2024-01-15T17:16:34.406Z">
<meta property="article:author" content="Kizurena">
<meta property="article:tag" content="Galgame">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kizureina.github.io/images/image-20240116003143388.png">
  
    <link rel="alternate" href="/atom.xml" title="Kizureina's Blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/banner.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Kizureina's Blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS 订阅">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="搜索" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/assets/avatar.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Kizureina </div>
      <div class="dot"></div>
      <div class="subtitle">I know nothing except the fact of my ignorance. </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/Kizureina" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Anime/" rel="tag">Anime</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Comic/" rel="tag">Comic</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Galgame/" rel="tag">Galgame</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Machine-Learning/" rel="tag">Machine Learning</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/RCE/" rel="tag">RCE</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Reverse-shell/" rel="tag">Reverse shell</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/java-RCE/" rel="tag">java RCE</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">嵌入式</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%A1%AC%E4%BB%B6/" rel="tag">硬件</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/archives/2024/01 ">
          一月 2024 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/12 ">
          十二月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/11 ">
          十一月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/10 ">
          十月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/09 ">
          九月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/07 ">
          七月 2023 
          <div class="archive-count">5 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/06 ">
          六月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/03 ">
          三月 2023 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/02 ">
          二月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/01 ">
          一月 2023 
          <div class="archive-count">4 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/12 ">
          十二月 2022 
          <div class="archive-count">3 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/11 ">
          十一月 2022 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/09 ">
          九月 2022 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/06 ">
          六月 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/04 ">
          四月 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/03 ">
          三月 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/02 ">
          二月 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/01 ">
          一月 2022 
          <div class="archive-count">3 </div>
        </a>
      
        <a class="archive-link" href="/archives/2021/12 ">
          十二月 2021 
          <div class="archive-count">1 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <li>
            <a href="/2024/01/11/galgame-reverse-learning-note/">Windows逆向进阶</a>
          </li>
        
          <li>
            <a href="/2024/01/01/Code-and-lonely-and-galgame/">代码与孤独与Galgame</a>
          </li>
        
          <li>
            <a href="/2023/12/18/Anime-and-reality/">动画与现实</a>
          </li>
        
          <li>
            <a href="/2023/11/26/d2l-machine-learning-note/">深度学习入门笔记</a>
          </li>
        
          <li>
            <a href="/2023/10/04/Thinking-of-Yusuteia/">《秽翼的尤斯蒂娅》随想</a>
          </li>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-galgame-reverse-learning-note" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        Windows逆向进阶
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-01-11T06:55:04.000Z" itemprop="datePublished">2024-01-11</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/Reverse/">Reverse</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            4.4k 词 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Galgame/" rel="tag">Galgame</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p><img src="/../images/image-20240116003143388.png" alt="image-20240116003143388"></p>
<h1 id="Hook基础"><a href="#Hook基础" class="headerlink" title="Hook基础"></a>Hook基础</h1><p>Hook的概念无需多言，简单来讲就是监听某个API函数，来对这个函数做相关操作，之后再跳转回到原本的函数继续执行。</p>
<h2 id="两种Hook方式"><a href="#两种Hook方式" class="headerlink" title="两种Hook方式"></a>两种Hook方式</h2><p>Hook的方式有inline和address两种。</p>
<h4 id="inline-Hook"><a href="#inline-Hook" class="headerlink" title="inline Hook"></a>inline Hook</h4><p>即内联Hook，<strong>直接在要Hook的函数处修改机器码</strong>，让程序执行跳转到我们写好的地址，来执行我们的函数，执行完后再跳转回到原函数处执行。</p>
<h4 id="address-Hook"><a href="#address-Hook" class="headerlink" title="address Hook"></a>address Hook</h4><p>即通过<strong>修改call的地址实现Hook</strong>。然后修改地址处的代码，执行完我们写好的代码后再跳转回到原本的函数。</p>
<p>实际上两种方式是一样的。</p>
<h2 id="两种跳转JMP-E9-与CALL-E8-的区别"><a href="#两种跳转JMP-E9-与CALL-E8-的区别" class="headerlink" title="两种跳转JMP(E9)与CALL(E8)的区别"></a>两种跳转JMP(E9)与CALL(E8)的区别</h2><p>Hook的基础是跳转，有两种汇编指令实现，分别是jmp与call。</p>
<h4 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h4><p>call在执行时会改变ESP和EIP寄存器的值，并将call指令的下一条指令的地址压入栈中。</p>
<p>如果使用call，因为会改变栈，所以有两种解决：</p>
<ol>
<li>直接在call完后加一条popad指令，将入栈的地址弹出</li>
<li>在call之前对栈指针ESP做操作，加一条<code>ADD esp,4</code>(32位地址)，就可以将ESP指针修改回来。</li>
</ol>
<h4 id="Jmp"><a href="#Jmp" class="headerlink" title="Jmp"></a>Jmp</h4><p>jmp更简单粗暴，跳转对寄存器没有改变。</p>
<p>但要注意的是：<strong>jmp后的参数跳转地址都是相对地址</strong>(RVA)，需要计算。</p>
<p>例如<code>jmp 0x09</code>，即向下跳转到九个字节后的地址，如果是负值则向上跳转，例如<code>jmp 0xF9FFFFFF</code>。</p>
<h5 id="jmp参数相对地址计算"><a href="#jmp参数相对地址计算" class="headerlink" title="jmp参数相对地址计算"></a>jmp参数相对地址计算</h5><p>跳转地址计算一般可以使用这个公式：</p>
<blockquote>
<p>目标地址 - 当前地址 - 5</p>
<p>为什么会减五呢？其实是减去你写的跳转代码的长度，即<code>jmp 0x12345678</code>长度为五个字节。</p>
</blockquote>
<p>使用OD或者x32dbg会帮你计算，所以用地址就可以，但如果写成代码需要自己写好。</p>
<h4 id="其他跳转方式"><a href="#其他跳转方式" class="headerlink" title="其他跳转方式"></a>其他跳转方式</h4><p>也可以用栈实现跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 0x12345678</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>这种方式不会改变栈和寄存器，很常用。</p>
<h2 id="栈平衡"><a href="#栈平衡" class="headerlink" title="栈平衡"></a>栈平衡</h2><p>我们hook后的函数必须要实现栈平衡，否则会影响原程序正常执行。</p>
<p>栈平衡有多种策略，取决于函数调用约定，常用的有三种：</p>
<ol>
<li><p>cdecl(<strong>C&#x2F;C++默认调用约定</strong>)</p>
<p>（1）参数从右向左依次压入堆栈.<br>（2）由调用者恢复堆栈，称为手动清栈。<br>（3）函数名自动加前导下划线。</p>
</li>
<li><p>stdcall(<strong>Windows API默认方式)</strong></p>
<p>（1）参数从右向左依次压入堆栈.<br>（2）由被<strong>调用函数</strong>自己来恢复堆栈，称为自动清栈。<br>（3）函数名自动加前导下划线，后面紧跟着一个@，其后紧跟着参数的大小。</p>
</li>
<li><p>fastcall</p>
<p>通过 CPU 寄存器来传递参数。此方式的函数的第一个和第二个DWORD参数通过ecx和edx传递，后面的参数从右向左的顺序压入栈。被调用函数清理堆栈。</p>
</li>
</ol>
<p>Hook的目标函数，与你写好的Hooked函数必须调用约定一致，否则会造成栈不平衡。</p>
<h1 id="Hook任意位置"><a href="#Hook任意位置" class="headerlink" title="Hook任意位置"></a>Hook任意位置</h1><h2 id="改写Hook点"><a href="#改写Hook点" class="headerlink" title="改写Hook点"></a>改写Hook点</h2><p>首先需要修改内存属性，由可读可执行改为可读可写可执行：一般使用<code>VirtulProtect()</code></p>
<p>写入内存一般有两种方式：<code>memcpy()</code>和<code>WriteProcessMemory()</code></p>
<p>注意的Hook流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualProtect</span>((LPVOID)orgAddr, <span class="number">0x5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">DWORD rvaAddr = tarAddr - orgAddr - <span class="number">0x5</span>;</span><br><span class="line"></span><br><span class="line">BYTE code[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;code[<span class="number">1</span>], &amp;rvaAddr, <span class="number">0x4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)orgAddr, code, <span class="number">0x5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="实例-Hook任意函数的某行代码"><a href="#实例-Hook任意函数的某行代码" class="headerlink" title="实例:Hook任意函数的某行代码"></a>实例:Hook任意函数的某行代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> WINAPI <span class="title">myTest</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">My_fun</span>()</span><br><span class="line">&#123;</span><br><span class="line">	__asm mov eax, eax</span><br><span class="line">	__asm ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD orgAddr = <span class="number">0x0041247E</span>; <span class="comment">// 0x0041243E;</span></span><br><span class="line">DWORD retAddr = <span class="number">0x00412483</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">MyHook</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 需要注意栈平衡</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;Hello!&quot;</span>, <span class="string">L&quot;this is a test box&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意push和pop顺序</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__asm push <span class="number">0xF1F4</span></span><br><span class="line">	__asm jmp retAddr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteHookCode</span><span class="params">(DWORD tarAddr, DWORD orgAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)orgAddr, <span class="number">0x5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">	DWORD rvaAddr = tarAddr - orgAddr - <span class="number">0x5</span>;</span><br><span class="line"></span><br><span class="line">	BYTE code[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;code[<span class="number">1</span>], &amp;rvaAddr, <span class="number">0x4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将hook代码写入目标地址</span></span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="type">void</span>*)orgAddr, code, <span class="number">0x5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">WriteHookCode</span>((DWORD)MyHook, orgAddr);</span><br><span class="line">	<span class="built_in">RunMethod1</span>();</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello, world!\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路其实很清楚，用vs或者x32dbg调一下也能搞明白。</p>
<p>注意：如果要直接写好RVA地址做Hook的话，必须把<strong>地址随机化修改掉</strong>，在Visual Studio项目属性-&gt;链接器-&gt;高级的编译选项中修改即可，否则每次编译都是不同的ImageBase。</p>
<p>但是有点奇怪的是这里：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DWORD orgAddr = <span class="number">0x0041247E</span>; <span class="comment">// 0x0041243E;</span></span><br><span class="line">DWORD retAddr = <span class="number">0x00412483</span>;</span><br></pre></td></tr></table></figure>

<p>Hook点的地址会根据<code>MyHook()</code>中内容改变，多半是MyHook函数写好的汇编代码，会占一部分内存空间导致的。</p>
<p>retAddr实际上就是orgAddr + 0x5，Hook点之后的五个字节，即修改为jmp 0xXXXXXXXX后的下一条指令。</p>
<p>另外：x32dbg 用来调试程序还方便的，如果直接用vs调试，需要先清理再重新生成，否则可能地址对不上。</p>
<h3 id="x32dbg快捷键"><a href="#x32dbg快捷键" class="headerlink" title="x32dbg快捷键"></a>x32dbg快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>f7</td>
<td>单步调试，遇到函数调用，会进入函数内部</td>
</tr>
<tr>
<td>f8</td>
<td>单步调试，遇到函数调用也会执行，不过会直接跳到执行后的语句</td>
</tr>
<tr>
<td>ctrl+f9</td>
<td>程序会一直运行，直到遇见第一个返回语句</td>
</tr>
<tr>
<td>alt+f9</td>
<td>若进入系统领空，此命令可瞬问回到应用程序领空</td>
</tr>
<tr>
<td>alt+b</td>
<td>打开断点</td>
</tr>
<tr>
<td>ctrl+g</td>
<td>搜索函数或者表达式</td>
</tr>
<tr>
<td>ctrl+n</td>
<td>查看程序调用的所有API函数</td>
</tr>
</tbody></table>
<h1 id="API-Hook"><a href="#API-Hook" class="headerlink" title="API Hook"></a>API Hook</h1><p>程序调用Windows API时，会将系统提供的DLL中的函数实现的调用路径复制到本程序中。但实际上，任何API函数的实现在系统中只有一份，其他所有程序都是调用这一份。</p>
<p>具体的实现是：编译器发现你调用了某个API时，会在生成的PE文件中写好导入表，操作系统在运行时，发现导入表中有某个DLL，会将对应的库函数加载到程序。</p>
<p>大部分API函数，只要在代码中写好函数名，就自动编译成地址，可以很容易的获取到地址。</p>
<p>另外某些函数实际上调用的是<strong>宏</strong>，例如<code>MessageBox</code>，实际上不是函数，而且系统根据你是否是x64判断后调用的<code>MessageBoxA</code>或者<code>MessageBoxW</code>，查看源码会发现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MessageBox  MessageBoxW</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MessageBox  MessageBoxA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure>

<p>当然还有未公开API，不能直接获取到地址。</p>
<h2 id="未公开API介绍"><a href="#未公开API介绍" class="headerlink" title="未公开API介绍"></a>未公开API介绍</h2><p>公开的WIndows API可以直接调用，但某些API是不能被代码直接调用的，例如<code>MessageBoxTimeOut()</code>，在函数导入表中可以发现，但在程序中写好调用会报错不能编译。</p>
<blockquote>
<p>未公开API的设计其实很有趣：如果所有API都公开，那微软就不能修改任何API的函数签名，否则会造成之前写好的代码不能运行，但未公开的话，只要修改公开调用的未公开函数即可，相当于有更好的向下兼容，可以减少因为版本修改造成的影响。</p>
</blockquote>
<p>那如何获取到未公开API的地址呢？很容易，手动调用<code>LoadLibraryW</code>或者<code>GetModuleHandle()</code>而不是用编译器获取就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetProcAddr</span><span class="params">(LPCWSTR dllName, LPCSTR procName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 大小写都可以</span></span><br><span class="line">    HMODULE hDll = <span class="built_in">LoadLibraryW</span>(dllName);</span><br><span class="line">    <span class="keyword">if</span> (hDll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    FARPROC addr = <span class="built_in">GetProcAddress</span>(hDll, procName);</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FreeLibrary</span>(hDll);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (DWORD)addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：获取到对应句柄或者地址后，需要Free掉。</p>
<h2 id="实例：Hook公开API-MessageboxA"><a href="#实例：Hook公开API-MessageboxA" class="headerlink" title="实例：Hook公开API(MessageboxA)"></a>实例：Hook公开API(MessageboxA)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD orgMsgBoxAddr;</span><br><span class="line">DWORD retMsgBoxAddr;</span><br><span class="line"><span class="function">DWORD <span class="title">GetProcAddr</span><span class="params">(LPCWSTR dllName, LPCSTR procName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 大小写都可以</span></span><br><span class="line">    HMODULE hDll = <span class="built_in">LoadLibraryW</span>(dllName);</span><br><span class="line">    <span class="keyword">if</span> (hDll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    FARPROC addr = <span class="built_in">GetProcAddress</span>(hDll, procName);</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FreeLibrary</span>(hDll);</span><br><span class="line">    <span class="keyword">return</span> (DWORD)addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteHookCode</span><span class="params">(DWORD tarAddr, DWORD orgAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)orgAddr, <span class="number">0x5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    DWORD rvaAddr = tarAddr - orgAddr - <span class="number">0x5</span>;</span><br><span class="line">    BYTE code[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span> &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;code[<span class="number">1</span>], &amp;rvaAddr, <span class="number">0x4</span>);</span><br><span class="line">    <span class="comment">// 将hook代码写入目标地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span>*)orgAddr, code, <span class="number">0x5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID __declspec(naked) <span class="built_in">MyMessageBox</span>(_In_opt_ HWND hWnd,</span><br><span class="line">    _In_opt_ LPCSTR lpText,</span><br><span class="line">    _In_opt_ LPCSTR lpCaption,</span><br><span class="line">    _In_ UINT uType)</span><br><span class="line">&#123;</span><br><span class="line">    __asm push ebp</span><br><span class="line">    __asm mov ebp,esp</span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        pushad</span><br><span class="line">        pushfd</span><br><span class="line">    &#125;</span><br><span class="line">    lpText = <span class="string">&quot;MyHook&quot;</span>;</span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        popfd</span><br><span class="line">        popad</span><br><span class="line">        jmp retMsgBoxAddr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Hook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    orgMsgBoxAddr = <span class="built_in">GetProcAddr</span>(<span class="string">L&quot;user32.dll&quot;</span>, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    retMsgBoxAddr = orgMsgBoxAddr + <span class="number">0x5</span>;</span><br><span class="line">    <span class="built_in">WriteHookCode</span>((DWORD)MyMessageBox, orgMsgBoxAddr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Hook</span>();</span><br><span class="line">    DWORD addrMSG1 = (DWORD)MessageBoxA;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Yoruko&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：我们写好的Hook后的函数中，如果调用了原函数的参数列表，在还原函数时必须首先执行这两行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br></pre></td></tr></table></figure>

<p>这两行是<code>MessageBoxA</code>原函数中被我们覆盖掉的五个字节中的三个字节，这个函数在user32.dll中的实现最开头三行如下：</p>
<p><img src="/../images/Snipaste_2024-01-14_16-49-38.png" alt="pFPj7Is.png"></p>
<p>但<code>move esi,esi</code>是编译器优化的占位符，实际上<strong>无操作</strong>(所以x32dbg这里标成了灰色)，所以不需要恢复。</p>
<p><code>push ebp</code> 和 <code>mov ebp, esp</code> 组合起来用于建立函数的调用帧，保存并设置函数的基址指针，以便函数能够正确地访问栈上的数据。这是典型的函数开头的常见操作。所以必须恢复，否则后面继续执行栈会出问题。</p>
<blockquote>
<p>当然不直接查看库函数的头几行，然后手动恢复，而是用<code>ReadMemory</code>动态获取，也是可以的，具体这部分可以参见我<a href="https://kizureina.github.io/2024/01/01/Code-and-lonely-and-galgame/">上一篇博客</a>中提供的Hook代码。</p>
</blockquote>
<p>之后的保存寄存器和还原寄存器也很重要，能保证Hook后程序的正常执行，并且还可以在hook后的函数中<strong>使用任意寄存器</strong>。</p>
<p>例如上面的修改参数列表不直接获取，而是使用堆栈修改也是可以的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str[] = <span class="string">&quot;myhook&quot;</span>;</span><br><span class="line"></span><br><span class="line">VOID __declspec(naked) <span class="built_in">myMsgBoxA</span>()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        pushad</span><br><span class="line">        pushfd</span><br><span class="line">    &#125;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov dword ptr[esp+<span class="number">0x2c</span>],offset str</span><br><span class="line">    &#125;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        popdf</span><br><span class="line">        popad</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp,esp</span><br><span class="line">        jmp retMessageBoxA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然需要调试查看具体传参的偏移量来修改<code>esp+0x2c</code>的值。</p>
<h2 id="未公开API-Hook"><a href="#未公开API-Hook" class="headerlink" title="未公开API Hook"></a>未公开API Hook</h2><p>这里要想一个问题：如果程序中调用了<strong>很多版本</strong>的MessageBox，或者你不知道具体用到了哪个版本的API（例如MessageBoxA，MessageBoxW,MessageBoxEx,MessageBoxExA,MessageBoxExW），怎么样才能一口气Hook到呢？</p>
<p>实际上大部分公开API，都调用了非公开API，例如MessageBoxA和MessageBoxW，就都调用了未公开的<code>MessageBoxTimeOutW</code>，所以有一个比较方便的办法，就是<strong>Hook未公开的API</strong>。</p>
<p>那么问题就又回到获取未公开API的地址了。</p>
<p>其实除了上面提到的手动加载，还有一个办法，就是让<strong>非公开API变成公开API</strong>（需要知道微软文档不会提供的非公开API的参数列表）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> WINAPI <span class="title">MessageBoxTimeoutA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IN HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">        IN LPCSTR LpText,</span></span></span><br><span class="line"><span class="params"><span class="function">        IN LPCSTR LpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">        IN UINT uType,</span></span></span><br><span class="line"><span class="params"><span class="function">        WORD wLanguageId,</span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dnMilliseconds)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> WINAPI <span class="title">MossageBoxTimeoutWs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IN HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">        IN LPCWSTR LpText,</span></span></span><br><span class="line"><span class="params"><span class="function">        IN LPCWSTR LpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">        IN UINT uType,</span></span></span><br><span class="line"><span class="params"><span class="function">        IN WORD wLanguageId,</span></span></span><br><span class="line"><span class="params"><span class="function">        IN DWORD dnMilliseconds)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但不是通用的方法。</p>
<p>言归正传，既然要加载非公开API，就需要定义这个API的参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* pMessageBoxTimeoutW)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN LPCWSTR lppText,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN UINT uType,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN WORD wLanguageId,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN DWORD dwMilliseconds)</span></span>;</span><br><span class="line"></span><br><span class="line">pMessageBoxTimeoutW orgMessageBoxTimeoutW;</span><br><span class="line"><span class="comment">// 写成这种形式也可以</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* pMessageBoxTimeoutW)</span><span class="params">(HWND, LPCWSTR, LPCWSTR, UINT, WORD, DWORD)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后获取地址就可以直接使用了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orgMessageBoxTimeoutW = (pMessageBoxTimeoutW)<span class="built_in">GetProcAddr</span>(<span class="string">L&quot;user32.dll&quot;</span>, <span class="string">&quot;MessageBoxTimeoutW&quot;</span>);</span><br><span class="line"><span class="built_in">orgMessageBoxTimeoutW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;hello&quot;</span>, <span class="string">L&quot;test&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>注意：这个函数的原型是<code>MessageBoxTimeoutW</code>，其中的out的o是小写，这里不能错一点，否则获取不到之前的函数地址。</p>
<p>到x32dbg里查看，发现甚至都没有加载user32.dll：</p>
<p><img src="/../images/Snipaste_2024-01-14_17-51-56.png" alt="pFiCs61.png"></p>
<p>因为没有在导入表中引入，而且我们手动加载的，在函数执行时会看到加载进来了：</p>
<p><img src="/../images/Snipaste_2024-01-14_17-53-29.png" alt="pFiCg0K.png"></p>
<p>获取到地址后，再执行正常的hook就可以了。</p>
<p>完整Hook代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD orgMsgBoxAddr;</span><br><span class="line">DWORD retMsgBoxAddr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* pMessageBoxTimeoutW)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN LPCWSTR lppText,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN UINT uType,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN WORD wLanguageId,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN DWORD dwMilliseconds)</span></span>;</span><br><span class="line">pMessageBoxTimeoutW orgMessageBoxTimeoutW;</span><br><span class="line"><span class="function">DWORD <span class="title">GetProcAddr</span><span class="params">(LPCWSTR dllName, LPCSTR procName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hDll = <span class="built_in">LoadLibraryW</span>(dllName);</span><br><span class="line">	<span class="keyword">if</span> (hDll == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	FARPROC addr = <span class="built_in">GetProcAddress</span>(hDll, procName);</span><br><span class="line">	<span class="keyword">if</span> (addr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FreeLibrary</span>(hDll);</span><br><span class="line">	<span class="keyword">return</span> (DWORD)addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteHookCode</span><span class="params">(DWORD tarAddr, DWORD orgAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)orgAddr, <span class="number">0x5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">	DWORD rvaAddr = tarAddr - orgAddr - <span class="number">0x5</span>;</span><br><span class="line">	BYTE code[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span> &#125;;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;code[<span class="number">1</span>], &amp;rvaAddr, <span class="number">0x4</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="type">void</span>*)orgAddr, code, <span class="number">0x5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID __declspec(naked) <span class="built_in">MyMessageBoxTimeout</span>(_In_opt_ HWND hWnd,</span><br><span class="line">	_In_opt_ LPCWSTR lpText,</span><br><span class="line">	_In_opt_ LPCWSTR lpCaption,</span><br><span class="line">	_In_ UINT uType)</span><br><span class="line">&#123;</span><br><span class="line">	__asm push ebp</span><br><span class="line">	__asm mov ebp, esp</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">	&#125;</span><br><span class="line">	lpText = <span class="string">L&quot;MyHook&quot;</span>;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">		jmp retMsgBoxAddr</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Hook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	retMsgBoxAddr = (DWORD)orgMessageBoxTimeoutW + <span class="number">0x5</span>;</span><br><span class="line">	<span class="built_in">WriteHookCode</span>((DWORD)MyMessageBoxTimeout, (DWORD)orgMessageBoxTimeoutW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	orgMessageBoxTimeoutW = (pMessageBoxTimeoutW)<span class="built_in">GetProcAddr</span>(<span class="string">L&quot;user32.dll&quot;</span>, <span class="string">&quot;MessageBoxTimeoutW&quot;</span>);</span><br><span class="line">	<span class="built_in">Hook</span>();</span><br><span class="line">	<span class="built_in">orgMessageBoxTimeoutW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;hello&quot;</span>, <span class="string">L&quot;test&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">5000</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Yoruko&quot;</span>, <span class="string">&quot;hello-A&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;Yoruko&quot;</span>, <span class="string">L&quot;hello-W&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时测试发现任何版本的<code>MessageBox</code>都被Hook到了。</p>
<p>注意：这种方法有时不行，例如在LoadLibraryW时，是因为我们获取到函数地址中，对应的机器码中有跳转，导致hook到的函数仅仅是中间跳转部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov edi,edi</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">jmp dword ptr ds:[&lt;&amp;LoadLibraryW&gt;]</span><br></pre></td></tr></table></figure>

<p>这种写法的跳转部分机器码开头为<em>FF25</em>，所以我们可以对这个<strong>特征码做单独判断</strong>就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HMODUL hDll = <span class="built_in">LoadLibraryW</span>(moduleName);</span><br><span class="line">BYTE jmp[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hDll != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    orgAddr = <span class="built_in">GetProcAddress</span>(hDll, orgName);</span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), orgAddr, jmp, <span class="number">6</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="number">1f</span>(jmp[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; jmp[<span class="number">1</span>] == <span class="number">0x25</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FARPROC correctAddr = <span class="number">0</span>;</span><br><span class="line">        BYTE readAddr[<span class="number">4</span>] = &#123;jmp[<span class="number">2</span>], jmp[<span class="number">3</span>], jmp[<span class="number">4</span>], jmp[<span class="number">5</span>]&#125;;</span><br><span class="line">        DWORD* pReadAddr = (DWORD*)readAddr;</span><br><span class="line">        <span class="built_in">ReadProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), (LPVOID)*pReadAddr, &amp;correctAddr, <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">        orgAddr = correctAddr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(orgAddr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retAddr = (FARPRCO)((DWORD)orgAddr + <span class="number">5</span>);</span><br><span class="line">    	<span class="built_in">FreeLibrary</span>(hDll);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h1><p>如上所述的Hook只能操作自己进程的API，但大多数时候，是要hook目标进程的API，所以需要用到DLL注入。</p>
<p>因为每个进程的内存空间都是私有的，不能通过一个进程读写另一个进程的内存。那么我们如何Hook呢？很容易，把hook代码写进动态链接库，然后让目标进程加载这个动态链接库即可。</p>
<h2 id="动态链接库基础"><a href="#动态链接库基础" class="headerlink" title="动态链接库基础"></a>动态链接库基础</h2><p>加载动态链接库会造成线程创建的问题。创建dll时需要写一个DllMain，来判断出现某种消息时需要执行的代码。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">NewThreadFunc</span><span class="params">(LPVOID lpParamate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;NewThreadFunc&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">			<span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_PROCESS_ATTACH&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)NewThreadFunc, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">			<span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_THREAD_ATTACH&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">			<span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_THREAD_DETACH&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">			<span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_PROCESS_DETACH&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中这个switch判断了四种消息，或者说四种事件。分别是：<strong>进程创建，线程创建，线程退出，进程退出</strong>。</p>
<p>然后我们在进程创建的同时又创建了一个线程（即多线程程序）。</p>
<p>把这个动态链接库用显式引用的方式加载进来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;Dll1.dll&quot;</span>);</span><br><span class="line">	<span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;LoadLibraryW&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现弹窗依次出现，并且执行了多次，是因为有线程切换时，又触发了线程加载事件。</p>
<p>那么如何让目标进程加载我们的DLL呢？就有很多方法了。</p>
<h2 id="目标进程加载DLL"><a href="#目标进程加载DLL" class="headerlink" title="目标进程加载DLL"></a>目标进程加载DLL</h2><h3 id="远程线程创建"><a href="#远程线程创建" class="headerlink" title="远程线程创建"></a>远程线程创建</h3><p>最常用的是用远程线程：<code>CreateRemoteThread</code></p>
<p><a target="_blank" rel="noopener" href="https://github.com/AYIDouble/Simple-DLL-Injection">最简单的示例</a>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LPCSTR DllPath = <span class="string">&quot;C:\\Simple-DLL-Injection\\C++\\Debug\\testlib.dll&quot;</span>; <span class="comment">// The Path to our DLL</span></span><br><span class="line">	</span><br><span class="line">	HWND hwnd = <span class="built_in">FindWindowA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Tutorial-x86_64&quot;</span>); <span class="comment">// HWND (Windows window) by Window Name</span></span><br><span class="line">	DWORD procID; <span class="comment">// A 32-bit unsigned integer, DWORDS are mostly used to store Hexadecimal Addresses</span></span><br><span class="line">	<span class="built_in">GetWindowThreadProcessId</span>(hwnd, &amp;procID); <span class="comment">// Getting our Process ID, as an ex. like 000027AC</span></span><br><span class="line">	HANDLE handle = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, procID); <span class="comment">// Opening the Process with All Access</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate memory for the dllpath in the target process, length of the path string + null terminator</span></span><br><span class="line">	LPVOID pDllPath = <span class="built_in">VirtualAllocEx</span>(handle, <span class="number">0</span>, <span class="built_in">strlen</span>(DllPath) + <span class="number">1</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write the path to the address of the memory we just allocated in the target process</span></span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(handle, pDllPath, (LPVOID)DllPath, <span class="built_in">strlen</span>(DllPath) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a Remote Thread in the target process which calls LoadLibraryA as our dllpath as an argument -&gt; program loads our dll</span></span><br><span class="line">	HANDLE hLoadThread = <span class="built_in">CreateRemoteThread</span>(handle, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">	(LPTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>), pDllPath, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hLoadThread, INFINITE); <span class="comment">// Wait for the execution of our loader thread to finish</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Dll path allocated at: &quot;</span> &lt;&lt; hex &lt;&lt; pDllPath &lt;&lt; endl;</span><br><span class="line">	cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">VirtualFreeEx</span>(handle, pDllPath, <span class="built_in">strlen</span>(DllPath) + <span class="number">1</span>, MEM_RELEASE); <span class="comment">// Free the memory allocated for our dll path</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键是这一行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(LPTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>), pDllPath, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>但实际上获取到的<code>LoadLibraryA</code>的句柄是不太靠谱的，大部分时候可以通用，但没有必然的逻辑联系。</p>
<blockquote>
<p>两边地址没有必然联系。加载进内存和所有进程共用一个dll本质上也没什么关系，共享也不是指内存，本质上在一个进程中dll一开始也没有真正载入到内存，只是属于映射。dll是可以重定位的，系统的dll不一定每次都分配固定的地址，我就是把他映射的地址占了，他能怎么样，他只能自己重定位，这个时候地址就不一样了。</p>
</blockquote>
<p>当然这确实是最常用也最方便的DLL方法。</p>
<h3 id="IAT注入"><a href="#IAT注入" class="headerlink" title="IAT注入"></a>IAT注入</h3><p>IAT表是PE文件用来标识导入表的结构，Windows下PE文件有两张导入表，即IAT和INT，分别标识导入函数的名称和地址，在加载进内存以前两张表是一致的，但加载后IAT表会变成函数地址。</p>
<p>操作系统读到IAT表，会把对应的库链接到该程序中。</p>
<blockquote>
<p>注意：通过PE查看器看dll机构中的IAT表，经常发现函数名与代码中写好的不一样，是因为C++为了实现重载，会对函数在编译后做重命名，如果不想被重命名，在定义函数时加一个<code>extern &quot;C&quot;</code>即可。</p>
</blockquote>
<p>我们可以通过写好Dll后，再重建目标程序的IAT表，把我们的函数注入进去。</p>
<p>可以通过CFF Explorer重建IAT表。</p>
<p><img src="/../images/Snipaste_2024-01-15_17-28-35.png" alt="IAT injection"></p>
<p>这种方式就是直接修改静态的PE结构。</p>
<p>当然还有一种不直接修改IAT表的方式：就是在真正的程序执行前，<strong>写好一个loader</strong>，把我们写好的注入当作内存补丁，来在loader中创建真正的程序线程，然后再修改内存中IAT表。这种方式明显更好，但要复杂一些。</p>
<h3 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h3>
        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left  disabled "
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2024/01/01/Code-and-lonely-and-galgame/"
      title="代码与孤独与Galgame"
     >

    <p class="title-text">
      
        代码与孤独与Galgame
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>


  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <div id="comment-card" class="comment-card">
    <div class="main-title-bar">
      <div class="main-title-dot"></div>
      <div class="main-title">留言 </div>
    </div>
    <div id="vcomments"></div>
  </div>
  <script>
      new Valine({
          el: '#vcomments',
          appId: "j9YBSIHTlRyfuvPQqY50ARfV-gzGzoHsz",
          appKey: "Q7s9zRzne9zaSVrroDR2wgO8"
      })
  </script>
 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 Kizureina<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.style.opacity = 1;
        } else {
            btn.style.opacity = 0;
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
