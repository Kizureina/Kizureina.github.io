<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/fontawesome/css/brands.css" rel="stylesheet">
<link href="/fontawesome/css/solid.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B0FHXMTYNC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B0FHXMTYNC');
</script>
<!-- End Google Analytics -->

  
  <title>编译原理笔记 | Kizureina&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="第一章 引论 重点: 翻译程序，编译，解释，源程序，中间代码，目标代码 了解编译的过程，编译程序的构架图（图1.1） 表格管理，遍  编译与翻译 翻译：是指能把某种语言的源程序，在不改变语义的条件下，转换成另一种程序语言-&gt;目标语言程序。  解释：接受某高级语言的一个语句输入，进行解释并控制计算机执行，马上得到这句的解释结果，然后再接受下一句，关键：不产生目标程序，边解释边运行。  编译：将">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理笔记">
<meta property="og:url" content="https://kizureina.github.io/2024/06/04/Note-of-Compilation-Principle/index.html">
<meta property="og:site_name" content="Kizureina&#39;s Blog">
<meta property="og:description" content="第一章 引论 重点: 翻译程序，编译，解释，源程序，中间代码，目标代码 了解编译的过程，编译程序的构架图（图1.1） 表格管理，遍  编译与翻译 翻译：是指能把某种语言的源程序，在不改变语义的条件下，转换成另一种程序语言-&gt;目标语言程序。  解释：接受某高级语言的一个语句输入，进行解释并控制计算机执行，马上得到这句的解释结果，然后再接受下一句，关键：不产生目标程序，边解释边运行。  编译：将">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240604154014827.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240604163305178.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240604163700006.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240604171938779.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240604172933713.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240604191750750.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240605094302253.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240604231136689.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240604233359525.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240604233932181.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240605004531396.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240605010453816.png">
<meta property="og:image" content="https://kizureina.github.io/images/image-20240605010504629.png">
<meta property="article:published_time" content="2024-06-04T07:37:07.000Z">
<meta property="article:modified_time" content="2024-06-05T01:43:33.589Z">
<meta property="article:author" content="Kizurena">
<meta property="article:tag" content="Web Computer Science Anime Comic Galgame">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kizureina.github.io/images/image-20240604154014827.png">
  
    <link rel="alternate" href="/atom.xml" title="Kizureina's Blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/banner.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Kizureina's Blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
      <a class="main-nav-link" href="/links">Links</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS 订阅">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="搜索" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
      <a class="nav-dropdown-link" href="/links">Links</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/assets/avatar2.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Kizureina </div>
      <div class="dot"></div>
      <div class="subtitle">I know nothing except the fact of my ignorance. </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/Kizureina" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Advanced-Mathematics/" rel="tag">Advanced Mathematics</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Anime/" rel="tag">Anime</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Comic/" rel="tag">Comic</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Galgame/" rel="tag">Galgame</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Linear-Algebraic/" rel="tag">Linear Algebraic</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Machine-Learning/" rel="tag">Machine Learning</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/RCE/" rel="tag">RCE</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Reverse-shell/" rel="tag">Reverse shell</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">嵌入式</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%A1%AC%E4%BB%B6/" rel="tag">硬件</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/archives/2024/09 ">
          九月 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/08 ">
          八月 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/07 ">
          七月 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/06 ">
          六月 2024 
          <div class="archive-count">5 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/05 ">
          五月 2024 
          <div class="archive-count">5 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/04 ">
          四月 2024 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/03 ">
          三月 2024 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/02 ">
          二月 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/01 ">
          一月 2024 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/12 ">
          十二月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/11 ">
          十一月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/10 ">
          十月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/09 ">
          九月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/07 ">
          七月 2023 
          <div class="archive-count">5 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/06 ">
          六月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/03 ">
          三月 2023 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/02 ">
          二月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/01 ">
          一月 2023 
          <div class="archive-count">4 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/12 ">
          十二月 2022 
          <div class="archive-count">3 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/11 ">
          十一月 2022 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/09 ">
          九月 2022 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/06 ">
          六月 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/04 ">
          四月 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/03 ">
          三月 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/02 ">
          二月 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/01 ">
          一月 2022 
          <div class="archive-count">3 </div>
        </a>
      
        <a class="archive-link" href="/archives/2021/12 ">
          十二月 2021 
          <div class="archive-count">1 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <li>
            <a href="/2024/09/23/Log-of-interview-on-Sec/">2024秋招安全岗面经</a>
          </li>
        
          <li>
            <a href="/2024/08/01/Log-of-Summer-August/">暑假日志(八月)</a>
          </li>
        
          <li>
            <a href="/2024/07/12/Log-of-Summer/">暑假日志(七月)</a>
          </li>
        
          <li>
            <a href="/2024/06/18/Note-of-Linear-Algebraic/">线性代数笔记</a>
          </li>
        
          <li>
            <a href="/2024/06/11/Note-of-Local-Address-Net-Security2/">内网安全攻防笔记(下)</a>
          </li>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-Note-of-Compilation-Principle" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        编译原理笔记
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-06-04T07:37:07.000Z" itemprop="datePublished">2024-06-04</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/Reverse/">Reverse</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            7.7k 词 
          </div>
        </div>
        
      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><blockquote>
<p>重点:</p>
<p>翻译程序，编译，解释，源程序，中间代码，目标代码</p>
<p>了解编译的过程，编译程序的构架图（图1.1）</p>
<p>表格管理，遍</p>
</blockquote>
<h3 id="编译与翻译"><a href="#编译与翻译" class="headerlink" title="编译与翻译"></a>编译与翻译</h3><ul>
<li><p>翻译：是指能把某种语言的源程序，在不改变语义的条件下，转换成另一种程序语言-&gt;目标语言程序。</p>
</li>
<li><p>解释：接受某高级语言的一个语句输入，进行解释并控制计算机执行，马上得到这句的解释结果，然后再接受下一句，关键：不产生目标程序，边解释边运行。</p>
</li>
<li><p>编译：将高级语言转为低级语言，产生目标程序。</p>
</li>
</ul>
<p>编译程序的流程：</p>
<ol>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>中间代码生成</li>
<li>优化</li>
<li>目标代码生成</li>
</ol>
<blockquote>
<p>语法分析与语义分析的差别：语法分析主要检查编写代码时有无报错，即编译时错误；语义分析则是检查代码运行时是否符合规范，即运行时错误。</p>
<p>例如：</p>
<ul>
<li>else没有匹配的if &#x3D;&gt; 语法分析错误</li>
<li>数组下标越界 &#x3D;&gt; 语义分析错误</li>
</ul>
</blockquote>
<p><img src="/../images/image-20240604154014827.png" alt="image-20240604154014827"></p>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>主要有两种：推导和规约</p>
<p>最左推导 &#x3D;&gt; 最右规约</p>
<p>最右推导 &#x3D;&gt; 最左规约</p>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>对语法分析识别出的各类语法范畴，分析其含义，进行初步翻译，产生介于源代码和目标代码之间的一种代码。</p>
<p>分为两阶段工作</p>
<ul>
<li>对对每种语法范畴进行静态语义检查</li>
<li>若语义正确，就进行中间代码的翻译</li>
</ul>
<p>中间代码的形式：</p>
<p>主要有：<strong>四元式，三元式和逆波兰式</strong>。</p>
<h3 id="表格管理"><a href="#表格管理" class="headerlink" title="表格管理"></a>表格管理</h3><ul>
<li>用来记录源程序的各种信息以及编译过程中的各种状况。</li>
</ul>
<p>与编译的前三个阶段有关的表格有：</p>
<ul>
<li>符号表，常数表，标号表，分程序入口表，中间代码表等</li>
</ul>
<h3 id="遍"><a href="#遍" class="headerlink" title="遍"></a>遍</h3><p>定义：是对源程序或源程序的中间结果从头到尾扫描一次，并做有关的加工处理，生成新的中间结果和目标代码。</p>
<p>注意：<em>遍</em>与<em>阶段</em>毫无关系</p>
<p>单遍扫描与多遍扫描比较：</p>
<ul>
<li>多遍扫描的优缺点：</li>
<li>优点：节省内存空间，提高目标代码质量，使编译的逻辑结构清晰。</li>
<li>缺点：编译时间较长。</li>
</ul>
<p>注：在内存许可的情况下，还是遍数尽可能少些为好。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>高级语言编写的源程序都必须通过编译，产生目标代码后才能执行。（X）</li>
<li>多遍扫描的编译程序的多遍是指多次重复读源程序。（X）</li>
<li>目标程序一定是机器语言程序。 （X）</li>
<li>无论一遍扫描还是多遍扫描，编译器都要对源程序扫描一遍。（O）</li>
</ul>
<h2 id="第二章-高级语言及其语法描述"><a href="#第二章-高级语言及其语法描述" class="headerlink" title="第二章 高级语言及其语法描述"></a>第二章 高级语言及其语法描述</h2><blockquote>
<p>重点：</p>
<p>CHOMSKY形式语言描述0,1,2,3型文法，重点掌握2型上下文无关文法和正规文法</p>
<p>程序语言的语法描述：符号表示</p>
<p>上下文无关文法</p>
<p>重点：文法识别语言，或者给出语言写出相应文法，最左推导，最右推导</p>
</blockquote>
<h3 id="语法描述"><a href="#语法描述" class="headerlink" title="语法描述"></a>语法描述</h3><p>主要有以下三种结构组成：</p>
<ol>
<li>字母表（alphabet）</li>
<li>符号（字符）（symbol）</li>
<li>符号串（string）</li>
</ol>
<p>符号串运算：</p>
<ol>
<li>符号串的连结</li>
<li>集合的乘积</li>
<li>符号串的幂运算</li>
<li>集合的幂运算</li>
<li>集合的正闭包与星闭包(重要)</li>
</ol>
<h4 id="A-与A-的区别"><a href="#A-与A-的区别" class="headerlink" title="A+与A*的区别"></a>A+与A*的区别</h4><p>A*不包括空串，A+包括。</p>
<h3 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h3><h4 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h4><p>文法是规则的非空集合，即一个四元组：<br>$$<br>G&#x3D;(V_N,V_T,P,S)<br>$$</p>
<ol>
<li>V_n是非终结符的非空有限集</li>
<li>V_t是终结符的非空有限集</li>
<li>S是开始符号的非终结符</li>
<li>P是产生式的集合，且每个产生式形式为 p-&gt;α 。</li>
</ol>
<p>描述语言的文法不是唯一的。</p>
<h4 id="句型和句子"><a href="#句型和句子" class="headerlink" title="句型和句子"></a>句型和句子</h4><p>根据文法推导出来的符号串称为该文法的<em>句型</em>，仅含有终结符的句型称为<em>句子</em>。</p>
<h4 id="规范推导与规范规约"><a href="#规范推导与规范规约" class="headerlink" title="规范推导与规范规约"></a>规范推导与规范规约</h4><p>每次推导时，都对字符串最右边的非终结符做替换，称为<strong>最右推导</strong>，也叫规范推导。</p>
<p>此时推出的句型称为规范句型。</p>
<p>反过来，规范推导的逆过程称为规范规约，即<strong>最左规约</strong>。</p>
<h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><p>根据文法产生的所有句子的集合，称为语言。</p>
<h3 id="Chomsky四类文法"><a href="#Chomsky四类文法" class="headerlink" title="Chomsky四类文法"></a>Chomsky四类文法</h3><ol>
<li>0型文法：没有任何限制的文法(可能出现非终结符永远消除不了，无法终结)</li>
<li>1型文法：上下文有关文法</li>
<li>2型文法：上下文无关文法，推导与上下文无关</li>
<li>3型文法：即正规文法，有左线性文法与右线性文法两种。</li>
</ol>
<p>右线性：A-&gt;aB 或 A-&gt;a</p>
<p>左线性：A-&gt;Ba 或 A-&gt;a</p>
<p><img src="/../images/image-20240604163305178.png" alt="image-20240604163305178"></p>
<h3 id="语法树与文法二义性"><a href="#语法树与文法二义性" class="headerlink" title="语法树与文法二义性"></a>语法树与文法二义性</h3><p><img src="/../images/image-20240604163700006.png" alt="image-20240604163700006"></p>
<p>如果某个文法存在句子对应两棵不同的语法树(最左或最右推导)，则称文法是二义性的。</p>
<h2 id="第三章-词法分析"><a href="#第三章-词法分析" class="headerlink" title="第三章 词法分析"></a>第三章 词法分析</h2><blockquote>
<p>重点：</p>
<p>词法分析的任务，输出形式</p>
<p>状态转换图，正规式，正规集，正规文法，三者之间的关系</p>
<p>DFA,NFA</p>
<p>给出语言写出正规式</p>
<p>重点3.3节：正规式绘制出NFA,NFA的确定化以及最小化问题</p>
<p>正规文法与DFA之间的转换（P52）</p>
</blockquote>
<p>词法分析是编译的第一阶段，在单词的级别上分析和翻译源程序。</p>
<p>理论基础:</p>
<ul>
<li>有限自动机理论</li>
<li>有限自动机理论与正规文法、正规式之间在描述语言方面有一一对应的关系。</li>
</ul>
<h3 id="正规文法与有限自动机"><a href="#正规文法与有限自动机" class="headerlink" title="正规文法与有限自动机"></a>正规文法与有限自动机</h3><p>正规文法、正规集与正规式：</p>
<blockquote>
<p>一个正规语言可以用正规文法定义，也可以用正规式定义，对任意一个正规文法，存在一个定义同一个语言的正规式；同样，对每个正规式，存在一个生成同一语言的正规文法；有些正规语言很容易用文法定义，有些则用正规式定义更容易；两者之间可以转换，结构上具有等价性。</p>
<p>由正规文法或正规式定义的正规语言的集合构成正规集</p>
</blockquote>
<p>正规文法转为正规式：</p>
<ol>
<li>联立导出式</li>
<li>把方程组中的非终结符当作自变量</li>
<li>求出方程组的解，再得到开始符号非终结符S的解即为正规式</li>
</ol>
<h3 id="有限自动机-FA"><a href="#有限自动机-FA" class="headerlink" title="有限自动机(FA)"></a>有限自动机(FA)</h3><p>有限自动机是一种识别装置，它能准确地识别正规集。它为词法分析程序的构造提供了方法和工具。</p>
<p>有限自动机是具有离散输入输出系统的数学模型，它具有有限数目的内部状态，系统可以根据当前所处的状态和面临的输入字符决定系统的后继行为。</p>
<p>其当前状态概括了过去输入处理的信息。</p>
<h4 id="确定有限自动机-NFA-与非确定有限自动机-DFA-："><a href="#确定有限自动机-NFA-与非确定有限自动机-DFA-：" class="headerlink" title="确定有限自动机(NFA)与非确定有限自动机(DFA)："></a>确定有限自动机(NFA)与非确定有限自动机(DFA)：</h4><p>NFA：状态 + 输入得到一个确定的状态</p>
<p>DFA：状态 + 输入得到多个状态</p>
<p>DFA由一个五元组描述：<br>$$<br>M &#x3D; (S,\sigma,f,s_0,Z)<br>$$</p>
<ul>
<li>S为有限状态集合</li>
<li>Σ为有限字母表</li>
<li>f为单值映射</li>
<li>s0为唯一的初态</li>
<li>Z是终止状态集合</li>
</ul>
<p>NFA与DFA类似，唯一的区别是：<em>NFA的S是一个非空初态集，而不是确定的初态</em>。</p>
<h4 id="NFA的确定化"><a href="#NFA的确定化" class="headerlink" title="NFA的确定化"></a>NFA的确定化</h4><p>将NFA转为未化简的DFA，一般用子集法：</p>
<blockquote>
<ol>
<li><p>例如有NFA的状态q0,q1，分别为初态和末态。</p>
</li>
<li><p>设一个新状态集合I，则有初态I0&#x3D;{q0}，再代入NFA中，看I0接受字符之后转为的状态是否是I中没有的：</p>
</li>
<li><p>例如有{q0,1}&#x3D;{q1}，此时将该状态加入I，即I1&#x3D;{q1}。继续考察I1接收字符后转成的状态是否是新状态，重复这个过程即可得到未化简的DFA。</p>
</li>
</ol>
</blockquote>
<h4 id="DFA的最小化"><a href="#DFA的最小化" class="headerlink" title="DFA的最小化"></a>DFA的最小化</h4><blockquote>
<ol>
<li>将DFA的状态集合分为终态集和非终态集：因为终态可以识别空串，但非终态不行，因此可以区分</li>
<li>对划分后的集合分别读取各个终结符，<em>判断产生的状态是否包含在已经划分的几个集合中</em>。</li>
<li>如果均包含，则该集合已经不需要划分；如果出现新集合，则需要继续划分。重复直到子集合数不再增加。</li>
</ol>
</blockquote>
<h4 id="DFA与正规式转换"><a href="#DFA与正规式转换" class="headerlink" title="DFA与正规式转换"></a>DFA与正规式转换</h4><p><img src="/../images/image-20240604171938779.png" alt="image-20240604171938779"></p>
<p>反过来由DFA写正规文法时，比较容易，需要根据下面两条规则：</p>
<ol>
<li>当产生的状态B不属于终态集时：A -&gt; aB（右线性文法时）</li>
<li><em>B属于终态集时：A -&gt; a | aB</em></li>
</ol>
<h2 id="第四章-自上而下的语法分析"><a href="#第四章-自上而下的语法分析" class="headerlink" title="第四章 自上而下的语法分析"></a>第四章 自上而下的语法分析</h2><blockquote>
<p>重点：</p>
<p>语法分析器的功能，语法分析的方法</p>
<p>自上而下分析的问题：左递归和回溯，如何消除</p>
<p>LL（1）文法</p>
<p>首符集FIRST()，随符集FOLLOW（）</p>
<p>预测分析表的构造</p>
<p>利用分析表进行预测分析的步骤</p>
</blockquote>
<p>1、语法分析的地位</p>
<ul>
<li>是编译程序的核心部分。</li>
</ul>
<p>2、语法分析的任务</p>
<ul>
<li>识别由词法分析得出的单词序列是否是给定文法的句子。</li>
</ul>
<p>3、语法分析的理论基础</p>
<ul>
<li>上下文无关文法和下推自动机（PDA）</li>
</ul>
<p>4、语法分析的两种思路和方式：</p>
<blockquote>
<ol>
<li>自上而下分析：反复使用不同产生式做推导以匹配完整输入串；</li>
<li>自下而上分析：对输入串寻找不同的产生式做规约，直到规约到文法开始符号的非终结符S。</li>
</ol>
</blockquote>
<h3 id="下推自动机-PDA"><a href="#下推自动机-PDA" class="headerlink" title="下推自动机(PDA)"></a>下推自动机(PDA)</h3><p><img src="/../images/image-20240604172933713.png" alt="image-20240604172933713"></p>
<p>与FA相比，增加了一个下推栈。</p>
<p>PDA执行的动作由三个因素决定：</p>
<ol>
<li>当前状态</li>
<li>读头所指向的符号</li>
<li>下推栈的栈顶符号</li>
</ol>
<p>当下推栈与输入带均为<strong>空串</strong>时，说明此时语法分析完成，且<em>成功匹配输入串。</em></p>
<p>PDA是一个七元组，除了FA的四元组以外，还包括：</p>
<ul>
<li>下推栈字母表</li>
<li>下推栈的栈初始符号(一般是#)</li>
<li>各种字母表间的有限子集映射</li>
</ul>
<h4 id="PDA的三种状态"><a href="#PDA的三种状态" class="headerlink" title="PDA的三种状态"></a>PDA的三种状态</h4><ol>
<li>推导：栈顶为非终结符，将其出栈，并将其产生式入栈</li>
<li>匹配：栈顶与读头均为终结符，则可以匹配成功，一起出栈</li>
<li><em>回溯</em>：若栈顶与读头均为终结符，但不匹配，则说明推导出错，需要返回上次推导现场。</li>
</ol>
<p>若回溯到开始符号S，则此时PDA识别失败。</p>
<h3 id="不带回溯的自上而下语法分析"><a href="#不带回溯的自上而下语法分析" class="headerlink" title="不带回溯的自上而下语法分析"></a>不带回溯的自上而下语法分析</h3><h4 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h4><p>例如有文法：P -&gt; Pa | b</p>
<p>消除直接左递归后转为等价式：</p>
<ol>
<li>P -&gt; bP’ </li>
<li>P’ -&gt; aP’ | 空串</li>
</ol>
<h4 id="消除回溯"><a href="#消除回溯" class="headerlink" title="消除回溯"></a>消除回溯</h4><p>基本方法：预测和提取左因子</p>
<p><strong>预测</strong>：根据读头下的字符对应的预测分析表，选择候选式，使其第一个字符与读头下相同，即相对于向前看了一个字符。此时消除回溯（即保证候选式的唯一性）。</p>
<p>因此需要求非终结符的首符号集First(A)。</p>
<p>但是会出现非终结符的<em>候选式首符集相交</em>(例如A-&gt;B|C，B和C的首符集可能都含有a)的情况，此时仍然需要回溯，因此需要提取公共左因子。</p>
<p><strong>提取公共左因子</strong>：<img src="/../images/image-20240604191750750.png" alt="image-20240604191750750"></p>
<h3 id="预测分析程序与LL-1-文法"><a href="#预测分析程序与LL-1-文法" class="headerlink" title="预测分析程序与LL(1)文法"></a>预测分析程序与LL(1)文法</h3><p>预测分析表：指示非终极符和终结符对应时，需要做哪种推导。</p>
<p>构造预测分析表需要先构造字母表的<strong>首符集</strong>和<strong>随符集</strong>。</p>
<h4 id="First-α-集"><a href="#First-α-集" class="headerlink" title="First(α)集"></a>First(α)集</h4><ul>
<li>对非终极符：</li>
</ul>
<p>所有α可能推导出的<strong>第一个</strong>终结符或空串组成的集合。</p>
<p>如果α经过有限次推导可以得到空串，则将空串加入首符集。</p>
<ul>
<li>对终结符：</li>
</ul>
<p>终结符的首符集就是本身。</p>
<h4 id="Follow-α-集"><a href="#Follow-α-集" class="headerlink" title="Follow(α)集"></a>Follow(α)集</h4><blockquote>
<p>在产生式<em>右端</em>找的α后面的第一个终结符，加入α的随符集。</p>
<p>如果A可以推导出B，且B后无其他字符(如A-&gt;aB)，则将Follow(A)加入到Follow(B)；</p>
<p>最后将终止符#加入Follow集。</p>
</blockquote>
<h4 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h4><p>若文法G的预测分析表M中不含有多重定义项，则称G为<em>LL(1)文法</em>。</p>
<p>注意：</p>
<ol>
<li><p>LL(1)文法是无二义的，二义文法一定不是LL(1)文法。</p>
</li>
<li><p>LL的含义是从左到右扫描输入串，采用最左推导分析句子。</p>
</li>
<li><p>数字1表示分析句子时需向前看一个输入符号。</p>
</li>
</ol>
<h4 id="判断是否是LL-1-文法"><a href="#判断是否是LL-1-文法" class="headerlink" title="判断是否是LL(1)文法"></a>判断是否是LL(1)文法</h4><blockquote>
<ol>
<li>文法中不含有左递归和公共左因子</li>
<li>对每一个非终极符A，A的<em>各个产生式的候选首符集</em>两两不相交。</li>
<li>对于产生式中存在空串的非终极符B，First(B)与Follow(B)不相交。</li>
</ol>
</blockquote>
<h4 id="预测分析表构造"><a href="#预测分析表构造" class="headerlink" title="预测分析表构造"></a>预测分析表构造</h4><p>构造是根据文法的每个产生式：</p>
<ol>
<li>如果有A-&gt;α(终结符或非终极符)，则对α的首符集里的每个终结符a..，都把A-&gt;α加入到M[A,a]中；</li>
<li>如果右端产生式的首符集中有空串，则对左端A的Follow集中所有终结符b..，将产生式加入到M[A,b]中。</li>
</ol>
<h2 id="第五章-自下而上的语法分析"><a href="#第五章-自下而上的语法分析" class="headerlink" title="第五章 自下而上的语法分析"></a>第五章 自下而上的语法分析</h2><blockquote>
<p>重点：</p>
<p>归约，句柄，规范归约（最左归约），最左素短语，算符优先，LR</p>
<p>注意：LR(0)，算符优先（FIRSTVT LASTVT）,分析表，给句子出来要会做相应分析</p>
<p>列出给定文法的LR(0)项目，构造识别活前缀的DFA，根据DFA判断文法是否是LR（0）（关键在项目族内是否是移近-归约冲突，或规约规约冲突），如果没有冲突项，就继续构造它的LR(0)分析表。根据分析表分析某个给定的句子，写出分析过程（符号栈，状态栈，输入串的变化）。</p>
</blockquote>
<h3 id="规范规约的相关概念"><a href="#规范规约的相关概念" class="headerlink" title="规范规约的相关概念"></a>规范规约的相关概念</h3><ul>
<li>直接短语：构成一个更大非终极符的子树，且只有一次推导</li>
<li>素短语：至少包含一个<em>终结符</em>，且不包含其他更小素短语的直接短语。</li>
<li>句柄：最左直接短语(注意：<em>不要求是素短语</em>，因此可以不包含终结符)</li>
<li>最左素短语：语法分析树最左边的素短语，<strong>不要求是直接短语</strong>，可以跨代但必须含有终结符。</li>
</ul>
<blockquote>
<p>!!要注意直接短语与素短语的区别，句柄是直接短语，但可以不是素短语。!!</p>
</blockquote>
<ol>
<li>自下而上的语法分析思想：</li>
</ol>
<p>自下而上的语法分析是一个<em>最左归约</em>的过程：从输入串开始，朝文法的开始符号进行归约，直到到达文法的开始符号为止的过程。最左规约即最右推导的逆过程，也叫规范规约。</p>
<ol start="2">
<li>自下而上的PDA工作流程：</li>
</ol>
<p>主要是两种操作：<em>移进</em>和<em>规约</em></p>
<p>自左至右把输入串的符号一个一个移进栈，在移进过程中<em>不断查看栈顶符号串</em>，一旦形成某个句型的<strong>句柄</strong>时，就将此句柄用相应的产生式左部替换（归约)，若再形成句柄，就继续替换，直到栈顶不再形成句柄为止。然后继续移进符号，重复上面的过程直到栈顶只剩下文法的<em>开始符号</em>，输入串读完为止，这样就认为识别了一个句子。</p>
<ol start="3">
<li>具体分析句子时，一般是先写出推导过程，再画出对应的<strong>语法树</strong>，找出其中的最左直接短语(即句柄)，再用PDA分析句子规约-移入。</li>
</ol>
<p>此时就产生一个问题：当可以规约时，该如何规约？即如何刻画“可规约串”这个概念？</p>
<p>最直接的思路是：简单优先分析</p>
<h3 id="简单优先文法"><a href="#简单优先文法" class="headerlink" title="简单优先文法"></a>简单优先文法</h3><p>定义：一个文法G，如果它不含空串产生式，也不含任何右部相同的不同产生式。并且它的任何符号对(X,Y)（注：X、Y是非终结符或终结符），<em>要么没有关系，要么存在优先级相同或低于、高于等关系之一</em>，则这是一个简单优先文法。</p>
<p>PDA读入一个单词后，比较栈顶符号和该单词的优先级，若栈顶符号<strong>优先级</strong>低于该单词，继续读入；若栈顶符号优先级高于或等于读入符号，则找句柄进行归约，找不到句柄就继续读入。直到最后栈内只剩下开始符号，输入串读到#”为止。此时识别正确。</p>
<p>优先级的定义：</p>
<ol>
<li>X &#x3D; Y：当且仅当G中含有形如P -&gt; …XY….</li>
<li>X &lt; Y：当且伩当G中含有形如P -&gt; …XQ….的产生式，其中Q -&gt; Y….</li>
<li>X &gt; Y：当且仅当Y为文法G的<em>终结符</em>，G中有形如P -&gt; …QR..，且Q -&gt; ..X，Y ∈ first(R)</li>
</ol>
<h3 id="算符优先文法"><a href="#算符优先文法" class="headerlink" title="算符优先文法"></a>算符优先文法</h3><p>算符文法的定义：给定上下文无关文法G，若G中所有产生式右部都不包含两个<em>相继</em>的非终结符（即例如…AB…），则G为算符文法。</p>
<p>算符优先文法的<em>优先级</em>定义：</p>
<ol>
<li>a &#x3D; b：当且仅当G中含有形如P → ..ab..产生式，或者P-&gt;..aQb..产生式；</li>
<li>a &lt; b：当且仅当G中含有形如P → ..aR..的产生式，其中R可以广义推导为b…或Qb…..(即a之后有可以推导出b的非终极符时，优先级别低于b)；</li>
<li>a &gt; b：当且仅当G中有形如P → ..Rb..产生式，其中R广义推导为….a或….aQ。</li>
</ol>
<p>(注：即能进一步推导时，优先级更高)</p>
<p>若G中任何终结符序偶(a,b)<em>至多满足上述关系之一</em>(即不能同时满足几个关系)，则称G为<strong>算符优先文法</strong>(OPG).</p>
<h3 id="构造优先级表"><a href="#构造优先级表" class="headerlink" title="构造优先级表"></a>构造优先级表</h3><h4 id="FirstVT集和LastVT集"><a href="#FirstVT集和LastVT集" class="headerlink" title="FirstVT集和LastVT集"></a>FirstVT集和LastVT集</h4><p>先求各个非终结符的FirstVT集和LastVT集:</p>
<p><img src="/../images/image-20240605094302253.png" alt="image-20240605094302253"></p>
<p>这两个集合都很容易求，FirstVT即非终结符推导出的第一个终结符，或者经过多次推导得到的首个终结符；LastVT集即经过一步或多步推导得到的最后一个终结符。</p>
<p>构造完FirstVT集和LastVT集之后，就可以确定优先级关系：</p>
<p><img src="/../images/image-20240604231136689.png" alt="image-20240604231136689"></p>
<h4 id="通过优先级表判断规约优先级"><a href="#通过优先级表判断规约优先级" class="headerlink" title="通过优先级表判断规约优先级"></a>通过优先级表判断规约优先级</h4><ol>
<li>当栈顶字符的优先级大于读头时，即形成可规约串，对栈顶做<strong>规约</strong>。</li>
<li>当读头优先级更高或者优先级相等时，做<strong>进栈</strong>操作。</li>
</ol>
<h3 id="LR分析法"><a href="#LR分析法" class="headerlink" title="LR分析法"></a>LR分析法</h3><p>基本思想：在规范归约过程中，一方面记住已移进和归约出的整个符号串，另一方面根据所用的<em>产生式推测未来可能碰到的输入符号</em>。</p>
<p>LR分析器分析三个方面的信息：</p>
<ul>
<li>历史：记录在栈内的符号串移进、归约的历史情况；</li>
<li>展望：预测句柄之后可能出现的信息；</li>
<li>现实：读头下的符号。</li>
</ul>
<p>L：从左向右扫描</p>
<p>R：构造最右推导的逆过程(即最左规约)</p>
<p>LR分析器的构成：语法分析程序(查分析表，做入栈出栈等操作) + 分析表。</p>
<p>因此关键就在如何构造和使用LR分析表。</p>
<p>最简单的分析表是LR(0)分析表。</p>
<h4 id="LR-0-分析表使用"><a href="#LR-0-分析表使用" class="headerlink" title="LR(0)分析表使用"></a>LR(0)分析表使用</h4><p><img src="/../images/image-20240604233359525.png" alt="image-20240604233359525"></p>
<p>S_i是状态，a_i表示终结符，A_i非终结符。</p>
<p>总控程序执行的操作根据栈顶状态S_m与读头下符号a_i查看得到：</p>
<ol>
<li>移进：将(S_m,a_i)的下一个状态S&#39; &#x3D; GOTO(S_m,a_i)连通读头下的字符进栈，栈顶成为(S’,a_i)，读头前进一格；</li>
<li>规约：指用某产生式A -&gt; B进行归约。若B的长度为r，则弹出栈顶的r个元素，使得栈顶的状态变成S_m-r，然后把(S_m-r,A)的下一个状态S’&#x3D;GOTO(S_m-r,A)连同非终结符A一起推进，栈顶变成(S’,A)，读头不动；</li>
<li>接收</li>
<li>报错</li>
</ol>
<p>LR(0)分析表中符号定义：</p>
<p><img src="/../images/image-20240604233932181.png" alt="image-20240604233932181"></p>
<p>即S_j的j是状态，r_j的j是第j个产生式，含义不同。</p>
<blockquote>
<p>注意：碰到r_j时进行规约，是将产生式反过来用。</p>
</blockquote>
<h4 id="LR文法判断"><a href="#LR文法判断" class="headerlink" title="LR文法判断"></a>LR文法判断</h4><p>定义：如果某一文法能够构造一张分析表，使得表中每一元素至多只有一种明确动作，则该文法称为<strong>LR文法</strong>。</p>
<p>注：并非所有CFG都是LR文法，但对于多数程序设计语言来说，一般都可以用LR文法描述。</p>
<h3 id="LR-0-分析表构造"><a href="#LR-0-分析表构造" class="headerlink" title="LR(0)分析表构造"></a>LR(0)分析表构造</h3><ul>
<li><p>基本思想：只根据历史信息识别呈现于栈顶的句柄。</p>
</li>
<li><p>基本策略：构造文法G的有限自动机，使其可以识别文法中的所有<em>活前缀</em>。</p>
</li>
</ul>
<p>前缀：字的任意首部，例如对ABC，前缀为空串，A，AB，ABC</p>
<p>活前缀：规范句型的一个前缀，<strong>且该前缀不含有句柄之后的任意字符</strong>(即凑出句柄以便规约)。</p>
<p>活前缀有两种类型：</p>
<ol>
<li>归态活前缀：即活前缀的尾部刚好是句柄的尾部，此时可以直接进行规约；</li>
<li>非归态活前缀：句柄尚未凑出来，需要继续移入符号。</li>
</ol>
<p>那么如何识别活前缀呢？</p>
<p>需要构造一个有限自动机：</p>
<h4 id="识别活前缀的有限自动机"><a href="#识别活前缀的有限自动机" class="headerlink" title="识别活前缀的有限自动机"></a>识别活前缀的有限自动机</h4><p>定义：由于产生式右部的符号串就是<em>句柄</em>，若这些符号串都已进栈，则表示它已处于归态活前缀，若只有部分进栈，则表示它处于非归态活前缀。要想知道活前缀有<strong>多大部分</strong>进栈了，可以为每个产生式构造一个自动机。由该自动机的“状态”来记住当前情况，此状态称为“项目”。</p>
<p>这些自动机的全体就是能识别所有活前缀的有限自动机。</p>
<p>项目：为文法的每一个产生式的右部添加一个圆点，圆点可以在产生式的任意位置，即生成不同的项目。</p>
<ol>
<li>例如产生式右部符号串长度为n，则可以产生n+1个项目</li>
<li>可以把圆点看作栈内外的分界线，即句柄的凑成进度。</li>
<li>生成空串的产生式只有一个项目。</li>
</ol>
<p>例如：</p>
<blockquote>
<ol>
<li>A → ·XYZ：预期要归约的句柄是XYZ，但都未进栈；</li>
<li>A → X·YZ：预期要归约的句柄是XYZ，仅X进栈；</li>
<li>A → XY·Z：预期要归约的句柄是XYZ，仅XY进栈；</li>
<li>A → XYZ·：已处于归态活前缀，XYZ可进行归约。     &lt;&#x3D;&#x3D;    这个项目是归约项目</li>
</ol>
</blockquote>
<p>因此，根据给出的文法可以构造识别活前缀的NFA：</p>
<ol>
<li>将仅出现在左部的非终结符作为唯一的初态，然后把所有n个产生式标记为对应的n个状态，再根据圆点的位置，将各个状态的转化图画出来即得到NFA。(例如上面1状态，识别X即转化为2状态；2状态识别Y即达到3状态。)；</li>
<li>将圆点在产生式最后时，到达终态；</li>
<li>若圆点后为<em>非终结符</em>A，则将该终态读取空串到达<strong>所有A -&gt; ·α(即圆点出现在最左边的A项目)的状态</strong>。</li>
</ol>
<p>画出NFA之后，即可通过词法分析中的方法确定化为<em>不含有空串</em>的DFA。</p>
<h4 id="构造识别活前缀DFA的另一种方法"><a href="#构造识别活前缀DFA的另一种方法" class="headerlink" title="构造识别活前缀DFA的另一种方法"></a>构造识别活前缀DFA的另一种方法</h4><p>对于拓广文法，即存在产生式S-&gt;S’的文法(不存在也可以构造)，有另一种写DFA的方法：</p>
<p>写NFA再确定化很麻烦，可以通过<em>拓广文法</em>的方式，直接写出DFA。</p>
<p>例如：起始状态对应的产生式为S-&gt;·E，此时圆点后为非终结符E，此时对该状态做<strong>拓广</strong>，扩大闭包范围，将<strong>所有</strong>E-&gt;·α的产生式加入状态0所代表的项目集，此时即为DFA中的起始状态。</p>
<p>圆点移动到E的后面时，此时识别完全，即为终结状态。</p>
<p>重复这个过程即可写出DFA。</p>
<h4 id="构造LR-0-分析表"><a href="#构造LR-0-分析表" class="headerlink" title="构造LR(0)分析表"></a>构造LR(0)分析表</h4><p>写出DFA之后，将状态写到分析表的的纵列，将终结符写道Action横列，非终结符写到GOTO横列。</p>
<p>此时即可构造LR(0)分析表，状态可以分成两类：归态(即圆点到达最后的状态)和非归态。</p>
<ul>
<li><p>对非归态：接收终结符到达另一个状态n，此时写入s_n；接收非终结符到另一个状态n，直接将状态数n填入。</p>
</li>
<li><p>对归态：接收任意非终结符，均做该状态本身对应产生式的规约操作r_m。</p>
</li>
</ul>
<p><img src="/../images/image-20240605004531396.png" alt="image-20240605004531396"></p>
<h2 id="第六章-属性文法与语法制导翻译"><a href="#第六章-属性文法与语法制导翻译" class="headerlink" title="第六章 属性文法与语法制导翻译"></a>第六章 属性文法与语法制导翻译</h2><h3 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h3><p>定义：属性文法是在上下文无关文法的基础上为每个文法符号（终结符或非终结符）配备若干个相关的“值”（称为属性）。</p>
<p>属性一般分为两类：综合属性和继承属性。</p>
<ul>
<li>综合属性用于“自下而上”传递信息</li>
<li>继承属性用于“自上而下”传递信息。</li>
</ul>
<p>属性加工的过程即是语义处理的过程，对于文法的每一个产生式都配备了一组属性的计算规则，则称为语义规则。</p>
<blockquote>
<p>注意：</p>
<p>1）终结符<em>只有</em>综合属性，它由词法分析器提供；</p>
<p>2）非终结符既可以有综合属性也可以有继承属性，文法开始符号的所有继承属性作为属性计算前的初始值。</p>
</blockquote>
<p>综合属性：</p>
<p>在语法树中，一个结点的综合属性的值由其<strong>子结点</strong>的属性值确定。因此，通常使用自底向上的方法在每一个结点处使用语义规则计算综合属性的值。 </p>
<p>继承属性：</p>
<p>在语法树中，一个结点的继承属性由此结点的<strong>父结点和&#x2F;或兄弟结点</strong>的某些属性确定。用继承属性来表示程序语言结构中的上下文依赖关系很方便。</p>
<h2 id="第七章-语义分析和中间代码的产生"><a href="#第七章-语义分析和中间代码的产生" class="headerlink" title="第七章 语义分析和中间代码的产生"></a>第七章 语义分析和中间代码的产生</h2><p>紧接在词法分析和语法分析之后，编译程序要做的工作是进行静态语义检查和翻译。</p>
<p>静态语义检查通常包括：</p>
<ol>
<li>类型检查</li>
<li>控制流检查</li>
<li>一致性检查</li>
<li>相关名字检查。</li>
</ol>
<p>翻译为中间语言的好处：</p>
<p>（1）便于进行与机器无关的代码优化；</p>
<p>（2）使编译程序改变目标机更容易；</p>
<p>（3）使编译程序的结构在逻辑上更为简单明确，以中间语言为界面，编译前端和后端的接口更清晰。</p>
<h3 id="中间语言"><a href="#中间语言" class="headerlink" title="中间语言"></a>中间语言</h3><p>首先要掌握几种中间语言的基本结构：逆波兰表示，图表示法（DAG 和抽象语法树），三地址代码（四元式、三元式、间接三元式）。</p>
<h4 id="逆波兰式"><a href="#逆波兰式" class="headerlink" title="逆波兰式"></a>逆波兰式</h4><p>将操作符放在后面，将操作数放在前面的中间语言写法。</p>
<p>例如：-a + b * (-c + d)</p>
<p>写出逆波兰式：(a-)b(c-)d+*+。先算乘除再算加减，其实很容易。</p>
<p>再比如 a + b * (c-d)&#x2F;e - f</p>
<p>写出逆波兰式：a bcd-* e&#x2F; +f-</p>
<p>后缀式(即逆波兰式)优点：易于计算机处理，常用方法是使用一个栈，自左向右扫描后缀式，没碰到运算对象就压栈，每碰到K目运算符就把它作用于栈顶的K个运算对象，并用运算的结果来取代栈顶的K个运算对象。</p>
<h4 id="三地址代码"><a href="#三地址代码" class="headerlink" title="三地址代码"></a>三地址代码</h4><p>三地址代码是由下面一般形式的语句构成的序列:</p>
<p>​       X:&#x3D;y op z</p>
<p>其中，x、y、z为名字、常数或编译时产生的临时变量；op代表运算符号如定点运算符、浮点运算符、逻辑运算符等。每个语句的右边只能有一个运算符。</p>
<h4 id="四元式"><a href="#四元式" class="headerlink" title="四元式"></a>四元式</h4><p>一个四元式是具有四个域的记录结构，表示为（op, arg1, arg2, result）。其中，OP表示运算符，arg1、arg2及result为指针，指向有关名字在符号表中的登记项或一<em>临时变量</em>。</p>
<p>四元式通过临时变量来传递数据。</p>
<h4 id="三元式"><a href="#三元式" class="headerlink" title="三元式"></a>三元式</h4><p>三元式是只具有3个域的记录结构，表示为（op, arg1, arg2）。其中，op为运算符，arg1、arg2即可指向有关名字在符号表中得登记项或临时变量，由名字自身表示，也可以指向三元式表示的某一个三元式编号。</p>
<p>示例分析：写出赋值语句a:&#x3D;b*(-c)+b*(-c)对应的三元式和四元式</p>
<p>三元式和四元式序列的顺序与表达式的计算顺序一致，其中四元式需要存放中间结果的<strong>临时单元</strong>，而三元式没有，用三元式的<strong>编号</strong>来代替，节省了编译程序需要的存储空间。在翻译时用*@来代表求一元负*。</p>
<p><img src="/../images/image-20240605010453816.png" alt="image-20240605010453816"></p>
<p><img src="/../images/image-20240605010504629.png" alt="image-20240605010504629"></p>
<p>三元式中arg2中的序号即前面三元式计算结果存储的地址。</p>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>（1）从功能上说，程序语言的语句大体可分为(执行性)语句和(说明性)语句。</p>
<p>（2）所谓语句制导翻译方法是为每个产生式配上一个(翻译子程序)，并在(语法分析)的同时执行它们。</p>
<p>（3）语法制导的翻译是基于属性文法的，属性有两大类，即(综合)属性和(继承)属性。</p>
<p>（4）在语法树中，一个结点的综合属性的值由其（子节点）的属性值确定，而继承属性则由该结点的（父节点或兄弟节点）的某些属性确定。</p>
<p>（5）语义分析阶段所生成的与源程序等价的中间表示形式可以由（逆波兰式、四元式与三元式）。</p>
<p>（6）生成中间代码主要是为了使（目标代码的优化容易实现）。</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/2024/06/08/Analysis-of-CVE-2024-4577/"
      title="古老漏洞的复活：php-cgi命令注入(CVE-2024-4577)漏洞分析"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        古老漏洞的复活：php-cgi命令注入(CVE-2024-4577)漏洞分析
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2024/05/27/Advanced-Mathematics-Review2/"
      title="高等数学拾遗(下)"
     >

    <p class="title-text">
      
        高等数学拾遗(下)
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>


  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <div id="comment-card" class="comment-card">
    <div class="main-title-bar">
      <div class="main-title-dot"></div>
      <div class="main-title">留言 </div>
    </div>
    <div id="vcomments"></div>
  </div>
  <script>
      new Valine({
          el: '#vcomments',
          appId: "j9YBSIHTlRyfuvPQqY50ARfV-gzGzoHsz",
          appKey: "Q7s9zRzne9zaSVrroDR2wgO8"
      })
  </script>
 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 Kizureina<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.style.opacity = 1;
        } else {
            btn.style.opacity = 0;
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
